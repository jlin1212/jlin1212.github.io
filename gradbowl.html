<html>
    <head>
        <title>G R A D B O W L</title>
        <style>
            * {
                padding: 0;
                margin: 0;
            }
        </style>
        <script src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
        <script src="https://unpkg.com/@cortex-js/compute-engine"></script>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/"
                }
            }
        </script>
        <script type="module">
            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

            const AMP = 1;
            const RESOLUTION = 50;
            const SCALE = 3;
            const ENV_POINTS = [];

            const minColor = new THREE.Color(0x375e4d);
            const maxColor = new THREE.Color(0xc72020);

            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();

            let currCast = null;
            let currMeshSolid = null;
            let currMeshWire = null;

            let mfield = document.getElementById('eqn');
            let ce = new ComputeEngine.ComputeEngine();

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xedfeff);
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

            const renderer = new THREE.WebGLRenderer();
            renderer.antialias = true;
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);

            function onPointerMove( event ) {
                pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            }

            function onPointerDown( event ) {
                if (currCast == null) return;
                console.dir(event);
                if (event.ctrlKey) alert('Added point.');
                // TODO: Add env point to list
            }

            function sampleSurface(expr) {
                let step = 2 * AMP / RESOLUTION;

                let colors = []
                let vertices = [];
                let indices = [];

                let zMin = Infinity;
                let zMax = -Infinity;

                for (let x = -AMP; x < AMP; x += step) {
                    for (let y = -AMP; y < AMP; y += step) {
                        let x_scaled = SCALE * x;
                        let y_scaled = SCALE * y;

                        ce.set({ x: x_scaled, y: y_scaled });

                        let z = expr.N().valueOf();
                        // let z = 0.1 * Math.sin(x_scaled**2 + y_scaled**2);

                        vertices.push(x, z, y);

                        if (z < zMin) zMin = z;
                        if (z > zMax) zMax = z;
                    }
                }

                for (let i = 0; i < vertices.length / 3; i++) {
                    if (zMin != zMax) {
                        let zNormed = (vertices[3*i+1] - zMin) / (zMax - zMin);
                        console.dir(zNormed);
                        let lerpColor = minColor.clone().lerp(maxColor, zNormed);
                        colors.push(lerpColor.r, lerpColor.g, lerpColor.b);
                    } else {
                        colors.push(maxColor.r, maxColor.g, maxColor.b);
                    }
                }

                // A very inefficient meshing procedure that just fills in alternating triangles in two passes, but
                // I was trying to get this done quick.

                for (let i = 0; i < RESOLUTION - 1; i++) {
                    for (let j = 0; j < RESOLUTION - 1; j++) {
                        let vert = i + j * RESOLUTION;
                        indices.push(vert, vert+1, vert+RESOLUTION);
                    }
                }

                for (let i = 1; i < RESOLUTION; i++) {
                    for (let j = 1; j < RESOLUTION; j++) {
                        let vert = i + j * RESOLUTION;
                        indices.push(vert, vert-RESOLUTION, vert-1);
                    }
                }

                console.log(indices)

                return {
                    'colors': new Float32Array(colors),
                    'vertices': new Float32Array(vertices),
                    'indices': indices
                }
            }

            function exprToMesh(expr) {
                document.getElementById('loading').style.display = 'block';

                let surface = sampleSurface(expr);

                const geometry = new THREE.BufferGeometry();
                geometry.setIndex(surface['indices']);
                geometry.setAttribute('color', new THREE.BufferAttribute(surface['colors'], 3))
                geometry.setAttribute('position', new THREE.BufferAttribute(surface['vertices'], 3))

                // const wireframe_mat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true });
                const wireframe_mat = new THREE.MeshBasicMaterial({
                    color: "black",
                    wireframe: true,
                    transparent: false,
                    opacity: 0.25
                });
                wireframe_mat.opacity = 0;
                const solid_mat = new THREE.MeshPhongMaterial( {
                    flatShading: true,
                    emissive: new THREE.Color(0xffffff),
                    emissiveIntensity: 0.1,
                    side: THREE.DoubleSide,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1,
                    vertexColors: true
                } );

                if (currMeshSolid != null) scene.remove(currMeshSolid);
                if (currMeshWire != null) scene.remove(currMeshWire);

                const wireframe = new THREE.Mesh(geometry, wireframe_mat);
                wireframe.scale.copy(new THREE.Vector3(1.5, 1.5, 1.5));
                currMeshWire = wireframe;
                scene.add(wireframe);

                const solid = new THREE.Mesh(geometry, solid_mat);
                solid.scale.copy(new THREE.Vector3(1.5, 1.5, 1.5));
                currMeshSolid = solid;
                scene.add(solid);

                document.getElementById('loading').style.display = 'none';
            }

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );

            const light = new THREE.DirectionalLight( 0xf2fbff, 1.3 );
            light.position.set( 0.03, 0.2, 0.2 );

            scene.add(ambientLight, light);

            camera.position.z = 0.3;
            camera.position.y = 2.5;

            controls.update();

            const GRID_SIZE = 3;

            let x_plane = new THREE.GridHelper(GRID_SIZE, 10, 0x222222, 0xbbbbbb);
            x_plane.rotation.x = Math.PI / 2;
            x_plane.position.z = -GRID_SIZE / 2;
            x_plane.position.y = GRID_SIZE / 2;

            let y_plane = new THREE.GridHelper(GRID_SIZE, 10, 0x222222, 0xbbbbbb);
            y_plane.rotation.z = Math.PI / 2;
            y_plane.position.x = -GRID_SIZE / 2;
            y_plane.position.y = GRID_SIZE / 2;

            let z_plane = new THREE.GridHelper(GRID_SIZE, 10, 0x222222, 0xbbbbbb);

            scene.add(x_plane, y_plane, z_plane);

            const castGeometry = new THREE.SphereGeometry(0.025);
            const castMaterial = new THREE.MeshStandardMaterial({
                flatShading: false,
                color: 0xffbf00,
                emissiveIntensity: 1,
                emissive: 0xffbf00,
                transparent: true
            });
            const castIndicator = new THREE.Mesh(castGeometry, castMaterial);
            scene.add(castIndicator);

            function animate() {
                requestAnimationFrame(animate);

                if (currMeshSolid != null) {
                    raycaster.setFromCamera(pointer, camera);
                    const intersections = raycaster.intersectObject(currMeshSolid);

                    if (intersections.length > 0) currCast = intersections[0].point;
                    else currCast = null;

                    if (currCast == null) castMaterial.opacity = 0;
                    else {
                        castMaterial.opacity = 1;
                        castIndicator.position.copy(currCast);
                    }
                } else {
                    castMaterial.opacity = 0;
                }

                controls.update();
                renderer.render(scene, camera);
            }

            window.addEventListener( 'pointermove', onPointerMove );
            window.addEventListener( 'pointerdown', onPointerDown );

            exprToMesh(ce.parse(mfield.getValue('latex')));

            mfield.addEventListener('beforeinput', evt => {
                if (evt.inputType == 'insertLineBreak') {
                    let expr = ce.parse(mfield.getValue('latex'));
                    let freeVars = expr.freeVars;
                    let extraVars = freeVars.toSpliced(freeVars.indexOf('x'), 1);
                    extraVars = extraVars.toSpliced(extraVars.indexOf('y'), 1);
                    if (extraVars.length > 0) alert("Sorry, I only know two letters of the alphabet, not: " + extraVars.toString());
                    else {
                        console.dir(expr);
                        exprToMesh(expr);
                    }
                    evt.preventDefault();
                }
            });

            requestAnimationFrame(animate);
        </script>
        <style>
            #controls {
                background-color: white;
                border: 1px solid #aaa;
                box-shadow: 0px 5px 4px rgba(0, 0, 0, 0.5);
                display: inline-block;
                padding: 20px;
                margin: 10px;
                position: absolute;
                right: 0;
            }

            #eqn {
                font-size: 20pt;
                padding: 10px;
            }

            #eqn-prefix {
                font-size: 20pt;
                font-style: italic;
                font-family: Georgia;
                letter-spacing: 12px;
            }

            .help {
                font-family: 'Arial', sans-serif;
                font-weight: bold;
                font-size: 10pt;
                margin-top: 10px;
                user-select: none;
            }

            kbd {
                margin: 0px 0.1em;
                padding: 0.1em 0.6em;
                border-radius: 3px;
                border: 1px solid rgb(204, 204, 204);
                color: rgb(51, 51, 51);
                line-height: 1.4;
                font-family: Arial,Helvetica,sans-serif;
                display: inline-block;
                box-shadow: 0px 1px 0px rgba(0,0,0,0.2), inset 0px 0px 0px 2px #ffffff;
                background-color: rgb(247, 247, 247);
                -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2), 0 0 0 2px #ffffff inset;
                -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2), 0 0 0 2px #ffffff inset;
                -moz-border-radius: 3px;
                -webkit-border-radius: 3px;
                text-shadow: 0 1px 0 #fff;
                user-select: none;
            }

            hr {
                margin-top: 15px;
            }

            #loading {
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(0, 0, 0, 0.7);
                color: #eee;
                font-family: Arial, Helvetica, sans-serif;
                font-size: 20pt;
                padding: 20px;
                z-index: 10000;
                text-shadow: 0px 2px 0px black;
            }
        </style>
    </head>
    <body>
        <div id="controls">
            <span id="eqn-prefix">z=</span><math-field id="eqn">0.1\sin(x^2+y^2)</math-field>
            <div class="help">Press <kbd>Enter</kbd> to apply your equation.</div>
            <div class="help">The function is only of <i>x</i> and <i>y</i>.</div>
            <hr />
        </div>
        <div id="loading">Loading...</div>
    </body>
    <script src="https://unpkg.com/mathlive"></script>
</html>