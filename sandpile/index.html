<html>
    <head>
        <title>The Abelian Sandpile</title>
        <style>
            body {
                margin: 0;
                padding: 0;
            }

            canvas {
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
            }
        </style>
    </head>
    <body>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/"
                }
            }
        </script>
        <script type="module">
            import * as THREE from 'three';

            const width = window.innerWidth;
            const height = window.innerHeight;

            const RES = 64;
            const SCALE = 0.45;
            const ortho_scale = 12;

            const dummy = new THREE.Object3D();

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            const camera = new THREE.OrthographicCamera(-width / ortho_scale, width / ortho_scale, height / ortho_scale, -height / ortho_scale, 0.1, 1000);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0xc97c5d });
            const mesh = new THREE.InstancedMesh(geometry, material, RES * RES * 4);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(mesh);

            camera.position.set(30, 60, 30);
            // camera.position.set(0, 30, 0);
            camera.lookAt(0, 0, 0);

            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const light = new THREE.DirectionalLight(0xfff2b0, 1.25);
            light.position.set(10, 30, 0);
            light.target.position.set(0, 0, 0);
            light.castShadow = true;
            scene.add(light);
            scene.add(light.target);

            const layer_colors = ['#774936', '#c38e70', '#deab90', '#edc4b3'];

            function render(grid) {
                let idx = 0;
                for (let z = 1; z <= 4; z++) {
                    for (let i = 0; i < RES; i++) {
                        for (let j = 0; j < RES; j++) {
                            let scale = (grid[i][j] >= z) ? 1 : 0;
                            dummy.position.set(i - (RES / 2), z, j - (RES / 2));
                            dummy.scale.set(scale, scale, scale);
                            dummy.updateMatrix();
                            mesh.setColorAt(idx, new THREE.Color(layer_colors[z-1]));
                            mesh.setMatrixAt(idx, dummy.matrix);
                            idx++;
                        }
                    }
                }
                mesh.instanceMatrix.needsUpdate = true;
                renderer.render(scene, camera);
            }

            let state_grid = Array(RES);
            for (let i = 0; i < RES; i++) {
                state_grid[i] = Array(RES);
                for (let j = 0; j < RES; j++) {
                    state_grid[i][j] = 4;
                }
            }

            render(state_grid);

            function update_state(state) {
                // let rand_i = Math.round(Math.random() * (RES - 1));
                // let rand_j = Math.round(Math.random() * (RES - 1));
                // state[rand_i][rand_j] += 1;

                let unstable_idx = [];
                for (let i = 0; i < RES; i++) {
                    for (let j = 0; j < RES; j++) {
                        if (state[i][j] >= 4) unstable_idx.push([i, j])
                    }
                }

                unstable_idx.forEach((idx) => {
                    state[idx[0]][idx[1]] -= 4;
                    if (idx[0] - 1 >= 0 && idx[1] - 1 >= 0) state[idx[0] - 1][idx[1] - 1] += 1;
                    if (idx[0] - 1 >= 0 && idx[1] + 1 < RES) state[idx[0] - 1][idx[1] + 1] += 1;
                    if (idx[0] + 1 < RES && idx[1] - 1 >= 0) state[idx[0] + 1][idx[1] - 1] += 1;
                    if (idx[0] + 1 < RES && idx[1] + 1 < RES) state[idx[0] + 1][idx[1] + 1] += 1;
                });

                return state;
            }

            console.log(setInterval(function() {
                state_grid = update_state(state_grid);
                render(state_grid);
            }, 10));
        </script>
    </body>
</html>