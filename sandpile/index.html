<html>
    <head>
        <title>The Abelian Sandpile</title>
        <style>
            body {
                background-color: white;
                margin: 0;
                padding: 0;
            }

            canvas {
                position: absolute;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
            }

            #info {
                position: absolute;
                top: 5%;
                left: 40px;
                z-index: 10;
                display: block;
                width: 20vw;
            }

            #info span {
                display: block;
            }

            #info .suptitle {
                font-size: 15pt;
                color: #333;
                font-family: 'Oswald', sans-serif;
                text-transform: uppercase;
            }

            #info .title {
                font-family: 'Oswald', sans-serif;
                text-transform: uppercase;
                font-size: 25pt;
                color: rgb(194, 46, 5);
                margin-bottom: 25px;
                text-shadow: 0px 2px black;
            }

            #info .stable {
                color: rgb(33, 33, 127);
            }

            #info .unstable {
                color: rgb(108, 25, 25);
            }

            #info .subtitle, p {
                font-family: 'Stack Sans Text', sans-serif;
                font-size: 10pt;
                color: #524939;
                text-align: justify;
                font-weight: 400;
            }

            #info b {
                color: #dd2525;
            }

            #info button {
                background-color: black;
                color: white;
                font-family: 'Oswald', sans-serif;
                text-transform: uppercase;
                border: none;
                padding: 10px 15px;
                cursor: pointer;
                margin: 20px 0px;
                font-size: 10pt;
                display: block;
            }

            #info button:hover {
                background-color: #333;
            }

            #switch {
                display: none;
                position: absolute;
                bottom: 30px;
                transform: translateX(50%);
                right: 50%;
                z-index: 100;
                border: none;
                background-color: rgb(175, 21, 21);
                color: white;
                font-family: 'Oswald', sans-serif;
                padding: 10px;
                font-size: 20pt;
                text-transform: uppercase;
                cursor: pointer;
            }

            #switch:hover {
                background-color: rgb(221, 37, 37);
            }

            #random-start {
                display: none;
            }

            #random-flavor {
                font-size: 11pt;
                margin-top: 60px;
            }

            #data-display {
                width: 20vw;
                top: 5%;
                right: 20px;
                position: absolute;
                display: none;
                z-index: 100;
            }

            #histogram {
                width: 100%;
                height: 200px;
                z-index: 100;
                display: flex;
                align-items: flex-end;
                position: relative;
            }

            #histogram::before {
                content: "Log-Histogram of Toppling Sizes";
                font-family: 'Stack Sans Headline';
                font-weight: 400;
                position: absolute;
                top: 0;
                right: 50%;
                transform: translateX(50%);
                width: 100%;
            }

            #histogram .bar {
                width: 10px;
                background-color: rgb(255, 136, 0);
                height: 0px;
                box-sizing: border-box;
                border: 1px solid white;
                transition: 0.1s linear;
            }

            #axis {
                position: absolute;
                bottom: 0;
                width: 100%;
                border-bottom: 2px solid black;
            }

            #axis::before, #axis::after {
                font-family: 'Stack Sans Headline';
                font-weight: 200;
                font-style: italic;
                font-size: 10pt;
            }

            #axis::before {
                content: 'smaller';
                position: absolute;
                left: 0;
            }

            #axis::after {
                content: 'larger';
                position: absolute;
                right: 0;
            }

            #pause {
                position: absolute;
                top: 5%;
                right: 50%;
                transform: translateX(50%);
                z-index: 101;
                text-transform: uppercase;
                font-family: 'Oswald', sans-serif;
                font-size: 25pt;
                transition: 0.1s linear;
                color: white;
                padding: 10px;
                background-color: rgba(0, 0, 0, 0.5);
                opacity: 0;
            }

            #pause.active {
                opacity: 1;
            }

            #buttons {
                position: absolute;
                bottom: 2%;
                left: 2%;
                z-index: 100;
            }

            #buttons button {
                height: 40px;
                width: 40px;
                line-height: 40px;
                padding: 0px;
                border-radius: 50%;
                border: none;
                background-color: #fffafa;
                color: rgb(14, 60, 87);
                box-shadow: 0px 2px 6px rgba(0, 0, 0, 0.45);
                font-family: 'Oswald', sans-serif;
                font-size: 20pt;
                margin: 5px;
                cursor: pointer;
            }

            #buttons button:hover {
                background-color: #eeeeee;
            }

            #credit {
                text-align: center;
                position: absolute;
                bottom: 5px;
                z-index: 100;
                width: 100vw;
                font-family: 'Arial', sans-serif;
                font-size: 8pt;
                color: #555;
            }

            #credit a {
                color: rgb(36, 130, 130);
                text-decoration: none;
            }
        </style>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Oswald:wght@200..700&family=Stack+Sans+Headline:wght@200..700&family=Stack+Sans+Text:wght@200..700&display=swap" rel="stylesheet">
    </head>
    <body>
        <button id="switch">Switch view</button>
        <div id="buttons">
            <button id="zoomOut">-</button>
            <button id="zoomIn">+</button>
        </div>
        <div id="credit">Made by <a href='https://jlin1212.github.io'>Jonathan Lin</a> in collaboration with <a href='https://www.complexityexplorer.org/#gsc.tab=0'>SFI Complexity Explorer.</a></div>
        <div id="info">
            <span class="suptitle">sandbox state:</span>
            <span class="title">saturated</span>
            <span class="subtitle">Every site in the sandbox is <b>unstable</b>, having a height of 4. Things look calm now, but starting the simulation will topple every site at once...</span>
            <button id="control">See what happens &rarr;</button>
            <p id="random-start">
                What happens if we start dropping grains of sand at random places on this state?
                <button id="random">Start a shower &rarr;</button>
            </p>
        </div>
        <div id="data-display">
            <div id="histogram">
                <div id="axis"></div>
            </div>
            <!-- <p id="random-flavor">
                Notice that some drops trigger long cascades&mdash;avalanches&mdash;while others do almost nothing.
                In really rare cases, an avalanche can span the entire lattice, if a drop happens at the right spot.
                This spot is called a <i>critical point</i>.
                <br /><br />
                You might think that eventually the pile settles down so that big avalanches become impossible. 
                In fact, one is always possible: the system <i>self-organizes</i> to become more critical over 
                time.
            </p> -->
        </div>
        <span id="pause">paused</span>
        <script src="https://d3js.org/d3.v4.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/"
                }
            }
        </script>
        <script type="module">
            import * as THREE from 'three';

            const width = window.innerWidth;
            const height = window.innerHeight;

            const RES = 64;
            const SCALE = 0.45;
            let ortho_scale = 12;

            const dummy = new THREE.Object3D();

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            const camera = new THREE.OrthographicCamera(-width / ortho_scale, width / ortho_scale, height / ortho_scale, -height / ortho_scale, 0.1, 1000);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.id = 'sandbox';
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({ color: 0xc38e70 });
            const mesh = new THREE.InstancedMesh(geometry, material, RES * RES * 4);

            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(mesh);

            camera.position.set(30, 60, 30);
            // camera.position.set(0, 30, 0);
            camera.lookAt(0, 0, 0);

            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const light = new THREE.DirectionalLight(0xfff2b0, 1.25);
            light.position.set(10, 30, 0);
            light.target.position.set(0, 0, 0);
            light.castShadow = true;
            scene.add(light);
            scene.add(light.target);

            const layer_colors = ['#774936', '#c38e70', '#deab90', '#dd2525'];

            function render(grid) {
                let idx = 0;
                for (let z = 1; z <= 4; z++) {
                    for (let i = 0; i < RES; i++) {
                        for (let j = 0; j < RES; j++) {
                            let scale = (grid[i][j] >= z) ? 1 : 0;
                            dummy.position.set(i - (RES / 2), z, j - (RES / 2));
                            dummy.scale.set(scale, scale, scale);
                            dummy.updateMatrix();
                            mesh.setColorAt(idx, new THREE.Color(layer_colors[z-1]));
                            mesh.setMatrixAt(idx, dummy.matrix);
                            idx++;
                        }
                    }
                }
                mesh.instanceMatrix.needsUpdate = true;
                renderer.render(scene, camera);
            }

            const drop_mesh = new THREE.Mesh(geometry, material);
            drop_mesh.position.set(0, 200, 0);
            scene.add(drop_mesh);

            const place_material = new THREE.MeshPhongMaterial({ color: 0x54b8ff });
            place_material.transparent = true;
            place_material.opacity = 0.6;
            const place_mesh = new THREE.Mesh(geometry, place_material);
            place_mesh.position.set(0, 200, 0);
            scene.add(place_mesh);

            const shadow_geometry = new THREE.PlaneGeometry(2, 2);
            const shadow_material = new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide });
            shadow_material.transparent = true;
            shadow_material.opacity = 0.5;
            const drop_shadow = new THREE.Mesh(shadow_geometry, shadow_material);
            drop_shadow.rotation.x = -Math.PI / 2;
            drop_shadow.position.set(0, 200, 0);
            scene.add(drop_shadow);

            let drop_i = null;
            let drop_j = null;
            let drop_height = null;
            let dropping = false;

            function shift_dropper() {
                dropping = true;
                drop_mesh.position.add(new THREE.Vector3(0, -2, 0));
                if (drop_mesh.position.y > drop_height) setTimeout(shift_dropper, 2);
                else {
                    dropping = false;
                    drop_mesh.position.setComponent(1, 200);
                    drop_shadow.position.setComponent(1, 200);
                    drop(state_grid, drop_i, drop_j);
                }
            }

            function render_drop(state_grid, drop_idx) {
                drop_i = drop_idx[0];
                drop_j = drop_idx[1];
                drop_mesh.position.set(drop_i - (RES / 2), 100, drop_j - (RES / 2));
                drop_shadow.position.set(drop_i - (RES / 2), 3.2, drop_j - (RES / 2));
                drop_height = state_grid[drop_i][drop_j] + 1;
                shift_dropper();
            }

            let state_grid = Array(RES);
            for (let i = 0; i < RES; i++) {
                state_grid[i] = Array(RES);
                for (let j = 0; j < RES; j++) {
                    state_grid[i][j] = 4;
                }
            }

            render(state_grid);

            let control = document.getElementById('control');
            let infoTitle = document.querySelector('#info .title');
            let infoText = document.querySelector('#info .subtitle');

            let unstable = false;
            let firstTopple = true;
            let randomGrains = false;
            let counting = false;
            let toppleCount = 0;

            let paused = false;

            function update_state(state) {
                let unstable_idx = [];
                for (let i = 0; i < RES; i++) {
                    for (let j = 0; j < RES; j++) {
                        if (state[i][j] >= 4) {
                            unstable_idx.push([i, j]);
                        }
                    }
                }

                if (unstable_idx.length > 0) {
                    if (counting) toppleCount += unstable_idx.length;
                    unstable = true;
                    unstable_idx.forEach((idx) => {
                        state[idx[0]][idx[1]] -= 4;
                        if (idx[0] - 1 >= 0 && idx[1] - 1 >= 0) state[idx[0] - 1][idx[1] - 1] += 1;
                        if (idx[0] - 1 >= 0 && idx[1] + 1 < RES) state[idx[0] - 1][idx[1] + 1] += 1;
                        if (idx[0] + 1 < RES && idx[1] - 1 >= 0) state[idx[0] + 1][idx[1] - 1] += 1;
                        if (idx[0] + 1 < RES && idx[1] + 1 < RES) state[idx[0] + 1][idx[1] + 1] += 1;
                    });
                } else {
                    unstable = false;
                }
            }

            function random_site(state) {
                document.getElementById('random-start').style.display = 'none';
                let rand_i = Math.round(Math.random() * (RES - 1));
                let rand_j = Math.round(Math.random() * (RES - 1));
                return [rand_i, rand_j];
            }

            function drop(state, i, j) {
                state[i][j] += 1;
            }

            control.onclick = function() {
                control.style.display = 'none';
                setInterval(function() {
                    if (!paused) {
                        update_state(state_grid);
                        render(state_grid);
                    }

                    if (unstable) {
                        infoTitle.innerHTML = '<i>Toppling...</i>';
                        infoTitle.classList.add('unstable');
                        infoTitle.classList.remove('stable');
                        infoText.innerHTML = `At least one site in the sandbox is currently <b>unstable</b>! It will lose 4 grains, transferring each to a neighbor...`
                    } else {
                        infoTitle.innerHTML = 'Stable';
                        infoTitle.classList.add('stable');
                        infoTitle.classList.remove('unstable');
                        infoText.innerHTML = `We've reached a stable state: all sites in the lattice have no more than 3 grains. However, things are never far from collapse...`;
                        if (firstTopple && !randomGrains) {
                            firstTopple = false;
                            document.getElementById('random-start').style.display = 'block';
                        }
                    }
                }, 25);
            };

            const switchView = document.getElementById('switch');
            let isoView = true;
            switchView.onclick = function() {
                if (isoView) camera.position.set(0, 60, 0);
                else camera.position.set(30, 60, 30);
                isoView = !isoView;
                render(state_grid);
            }

            let toppleCounts = [];

            document.getElementById('random').onclick = function() {
                document.getElementById('random-start').style.display = 'none';
                randomGrains = true;
                setInterval(function() {
                    if (counting) {
                        toppleCounts.push(toppleCount);
                        render_histogram();
                    }
                    toppleCount = 0;
                    
                    if (!placeSelected && !dropping) {
                        let drop_idx = random_site(state_grid);
                        render_drop(state_grid, drop_idx);
                        counting = true;
                    }
                }, 4000, true);
            }

            function render_histogram() {
                const x = d3.scaleLinear()
                    .domain([0, 1000]);

                let histogram = d3.histogram()
                    .value(d => d)
                    .domain(x.domain())
                    .thresholds(x.ticks(15));

                let bins = histogram(toppleCounts);
                let bin_counts = bins.map(b => b.length);
                bin_counts = bin_counts.map(b => b === 0 ? 0 : Math.log(b))
                let bin_scale = d3.max(bin_counts);

                document.getElementById('data-display').style.display = 'block';
                let bars = document.querySelectorAll('#histogram .bar');
                if (bars.length === 0) {
                    for (let i = 0; i < bins.length; i++) {
                        let bar = document.createElement('div');
                        bar.classList.add('bar');
                        document.getElementById('histogram').appendChild(bar);
                    }
                }
                bars = document.querySelectorAll('#histogram .bar');

                for (let i = 0; i < bins.length; i++) {
                    bars[i].style.height = `${Math.round(0.8*bin_counts[i]*document.getElementById('histogram').clientHeight/bin_scale)}px`;
                }

                console.log(bins, bin_counts);
            }

            document.getElementById('zoomIn').onmousedown = function(evt) {
                camera.zoom = THREE.MathUtils.clamp(
                    camera.zoom + 0.15,
                    0.5,
                    10
                );
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
            };

            document.getElementById('zoomOut').onmousedown = function(evt) {
                camera.zoom = THREE.MathUtils.clamp(
                    camera.zoom - 0.15,
                    0.5,
                    10
                );
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
            };

            window.onwheel = function(evt) {
                camera.zoom = THREE.MathUtils.clamp(
                    camera.zoom - 0.15 * Math.sign(evt.deltaY),
                    0.5,
                    10
                );
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
            };

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(-1, -1);

            let pauseIndicator = document.getElementById('pause');
            let sandbox = document.getElementById('sandbox');

            let placeSelected = false;
            let placeIdx = { i: null, j: null };

            function hide_placement() {
                placeSelected = false;
                place_mesh.position.set(0, 200, 0);
                renderer.render(scene, camera);
                sandbox.style.cursor = '';
            };

            sandbox.onmousemove = function(evt) {
                mouse.x = evt.clientX * 2 / window.innerWidth - 1;
                mouse.y = -(evt.clientY * 2 / window.innerHeight - 1);
                raycaster.setFromCamera(mouse, camera);
                let intersects = raycaster.intersectObject(mesh);

                if (intersects.length > 0 && randomGrains && !paused) {
                    let ix = Math.floor(intersects[0].point.x);
                    let iy = Math.floor(intersects[0].point.y);
                    let iz = Math.floor(intersects[0].point.z);
                    placeSelected = true;
                    placeIdx.i = ix + (RES / 2);
                    placeIdx.j = iz + (RES / 2);
                    placeIdx.instanceId = intersects[0].instanceId;
                    place_mesh.position.set(ix, iy + 1, iz);
                    renderer.render(scene, camera);
                    sandbox.style.cursor = 'pointer';
                } else hide_placement();
            };

            window.onkeydown = function(evt) {
                if (evt.keyCode === 32) {
                    if(!dropping && unstable) paused = !paused;
                    if (paused) pauseIndicator.classList.add('active');
                    else pauseIndicator.classList.remove('active');
                }
            };

            sandbox.onmousedown = function(evt) {
                if (placeSelected) {
                    hide_placement();
                    render_drop(state_grid, [placeIdx.i, placeIdx.j]);
                    counting = true;
                }
            };
        </script>
    </body>
</html>